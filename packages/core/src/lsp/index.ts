/**
 * @license
 * Copyright 2025 DeepV Code team
 * https://github.com/OrionStarAI/DeepVCode
 * SPDX-License-Identifier: Apache-2.0
 */


import * as path from 'node:path';
import * as fs from 'node:fs';
import { pathToFileURL } from 'node:url';
import { LSPClient, LSPServer } from './types.js';
import { createLSPClient, stopLSPClient } from './client.js';
import { DefaultServers } from './server.js';

export class LSPManager {
  private clients: Map<string, LSPClient.Info> = new Map(); // key: serverID + root
  private servers: LSPServer.Info[];
  private projectRoot: string;
  private openedFiles: Set<string> = new Set();
  private fileVersions: Map<string, number> = new Map();
  private fileContents: Map<string, string> = new Map();
  private freshClients: Set<string> = new Set(); // ğŸ¯ è¿½è¸ªåˆšå¯åŠ¨çš„å®¢æˆ·ç«¯

  constructor(projectRoot: string) {
    this.projectRoot = projectRoot;
    this.servers = DefaultServers(projectRoot);
  }

  /**
   * è·å–æˆ–åˆ›å»ºä¸€ä¸ªåŒ¹é…æ–‡ä»¶çš„ LSP Client
   */
  async getClientsForFile(file: string): Promise<LSPClient.Info[]> {
    const ext = path.extname(file).toLowerCase();
    const matchingServers = this.servers.filter(s => s.extensions.includes(ext));

    const results: LSPClient.Info[] = [];
    for (const serverInfo of matchingServers) {
      const root = await serverInfo.root(file);
      const key = `${serverInfo.id}:${root}`;

      if (this.clients.has(key)) {
        results.push(this.clients.get(key)!);
      } else {
        try {
          console.log(`[LSP] Starting ${serverInfo.id} for root ${root}`);
          const { process } = await serverInfo.spawn(root);
          const client = await createLSPClient({
            serverID: serverInfo.id,
            server: { process },
            root,
          });
          this.clients.set(key, client);
          this.freshClients.add(client.serverID); // ğŸ¯ æ ‡è®°ä¸ºæ–°å®¢æˆ·ç«¯
          results.push(client);
        } catch (e) {
          console.error(`[LSP] Failed to start ${serverInfo.id}:`, e);
        }
      }
    }
    return results;
  }

  /**
   * ç¡®ä¿æ–‡æ¡£åœ¨æœåŠ¡ç«¯å·²æ‰“å¼€å¹¶åŒæ­¥
   */
  async syncDocument(client: LSPClient.Info, file: string) {
    const uri = this.getUri(file);
    const key = `${client.serverID}:${uri}`;
    const content = fs.readFileSync(file, 'utf8');

    if (!this.openedFiles.has(key)) {
      this.fileVersions.set(key, 1);
      this.fileContents.set(key, content);
      await client.connection.sendNotification('textDocument/didOpen', {
        textDocument: {
          uri,
          languageId: this.getLanguageId(file),
          version: 1,
          text: content,
        }
      });
      this.openedFiles.add(key);
      // ğŸ¯ ç»™æœåŠ¡å™¨ä¸€ç‚¹æ—¶é—´è§£ææ–°æ‰“å¼€çš„æ–‡ä»¶
      await new Promise(resolve => setTimeout(resolve, 500));
    } else {
      const oldContent = this.fileContents.get(key);
      if (oldContent === content) {
        return; // å†…å®¹æœªå˜ï¼Œæ— éœ€åŒæ­¥
      }

      const version = (this.fileVersions.get(key) || 1) + 1;
      this.fileVersions.set(key, version);
      this.fileContents.set(key, content);

      await client.connection.sendNotification('textDocument/didChange', {
        textDocument: { uri, version },
        contentChanges: [{ text: content }]
      });
    }
  }

  private getLanguageId(file: string): string {
    const ext = path.extname(file).toLowerCase();
    switch (ext) {
      case '.ts': case '.tsx': return 'typescript';
      case '.js': case '.jsx': return 'javascript';
      case '.go': return 'go';
      case '.py': return 'python';
      case '.rs': return 'rust';
      default: return 'plaintext';
    }
  }

  /**
   * ğŸ¯ Windows å…¼å®¹æ€§ï¼šè·å–è§„èŒƒåŒ–çš„ URI
   */
  private getUri(file: string): string {
    const uri = pathToFileURL(path.resolve(file)).href;
    return uri.replace(/^file:\/\/\/([A-Z]):\//, (match, drive) => `file:///${drive.toLowerCase()}:/`);
  }

  async shutdown() {
    for (const client of this.clients.values()) {
      await stopLSPClient(client);
    }
    this.clients.clear();
    this.openedFiles.clear();
  }

  /**
   * æ‰§è¡Œ LSP è¯·æ±‚çš„é€šç”¨åŒ…è£…
   */
  async run<T>(
    file: string,
    task: (client: LSPClient.Info) => Promise<T>,
    options?: { timeoutMs?: number; operationName?: string },
  ): Promise<T[]> {
    const debug =
      process.env.DEEPV_LSP_DEBUG === '1' ||
      process.env.DEEPV_LSP_DEBUG === 'true';
    const timeoutMsFromEnv = Number(process.env.DEEPV_LSP_REQUEST_TIMEOUT_MS);
    const timeoutMs =
      options?.timeoutMs ??
      (Number.isFinite(timeoutMsFromEnv) && timeoutMsFromEnv > 0
        ? timeoutMsFromEnv
        : 15_000);
    const operationName = options?.operationName ?? 'request';

    // ğŸ¯ ç»Ÿä¸€è·¯å¾„æ ¼å¼ï¼Œé˜²æ­¢ Windows å¤§å°å†™é—®é¢˜
    const normalizedFile = path.normalize(file);
    const clients = await this.getClientsForFile(normalizedFile);
    const results = await Promise.all(
      clients.map(async (client) => {
        await this.syncDocument(client, normalizedFile);

        // ğŸ¯ æ ¸å¿ƒç­–ç•¥ï¼šç»™æ–° Server åŸºç¡€æš–æœºæ—¶é—´ï¼Œç¡®ä¿é¦–ä¸ªè¯·æ±‚çš„æˆåŠŸç‡
        if (this.freshClients.has(client.serverID)) {
          console.log(`[LSP][${client.serverID}] First request on fresh server, warming up for 3s...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
          this.freshClients.delete(client.serverID); // æš–æœºå®Œæˆ
        }

        try {
          const result = await Promise.race([
            task(client),
            new Promise<never>((_, reject) => {
              const t = setTimeout(() => {
                clearTimeout(t);
                reject(
                  new Error(
                    `[LSP][${client.serverID}] ${operationName} timed out after ${timeoutMs}ms`,
                  ),
                );
              }, timeoutMs);
            }),
          ]);
          return result;
        } catch (err) {
          // è¶…æ—¶/å¼‚å¸¸éƒ½ä¸åº”è¯¥é˜»å¡æ•´ä¸ª tool è°ƒç”¨ã€‚
          // å¯¹äºè¶…æ—¶åœºæ™¯ï¼Œè®°å½•å¿…è¦æ—¥å¿—å¹¶è·³è¿‡è¯¥ clientã€‚
          if (debug) {
            console.error(`[LSP][${client.serverID}] Request failed:`, err);
          } else {
            const message = err instanceof Error ? err.message : String(err);
            if (message.includes('timed out after')) {
              console.warn(message);
            } else {
              console.error(`[LSP][${client.serverID}] Request failed:`, message);
            }
          }
          return null;
        }
      })
    );

    const finalResults: T[] = [];
    for (const r of results) {
      if (r !== null) {
        finalResults.push(r as T);
      }
    }
    return finalResults;
  }

  // å…·ä½“çš„ LSP åŠŸèƒ½ API

  async getHover(file: string, line: number, character: number) {
    return this.run(
      file,
      (client) =>
        client.connection.sendRequest('textDocument/hover', {
          textDocument: { uri: this.getUri(file) },
          position: { line, character },
        }),
      { operationName: 'textDocument/hover' },
    );
  }

  async getDefinition(file: string, line: number, character: number) {
    return this.run(
      file,
      (client) =>
        client.connection.sendRequest('textDocument/definition', {
          textDocument: { uri: this.getUri(file) },
          position: { line, character },
        }),
      { operationName: 'textDocument/definition' },
    );
  }

  async getReferences(file: string, line: number, character: number) {
    return this.run(file, async (client) => {
      const params = {
        textDocument: { uri: this.getUri(file) },
        position: { line, character },
        context: { includeDeclaration: true }
      };
      let result = await client.connection.sendRequest('textDocument/references', params);

      // ğŸ¯ é‡è¯•é€»è¾‘ï¼šå¦‚æœæ˜¯ç©ºç»“æœï¼Œå¯èƒ½æ˜¯ç´¢å¼•å°šæœªå®Œæˆ
      if (!result || result.length === 0) {
        console.log(`[LSP][${client.serverID}] No references found, retrying in 3s...`);
        await new Promise(resolve => setTimeout(resolve, 3000));
        result = await client.connection.sendRequest('textDocument/references', params);
      }
      return result;
    }, { operationName: 'textDocument/references' });
  }

  async getImplementation(file: string, line: number, character: number) {
    return this.run(file, async (client) => {
      const params = {
        textDocument: { uri: this.getUri(file) },
        position: { line, character }
      };
      let result = await client.connection.sendRequest('textDocument/implementation', params);

      // ğŸ¯ é‡è¯•é€»è¾‘ï¼šå¦‚æœæ˜¯ç©ºç»“æœï¼Œå¯èƒ½æ˜¯ç´¢å¼•å°šæœªå®Œæˆ
      if (!result || result.length === 0) {
        console.log(`[LSP][${client.serverID}] No implementation found, retrying in 3s...`);
        await new Promise(resolve => setTimeout(resolve, 3000));
        result = await client.connection.sendRequest('textDocument/implementation', params);
      }
      return result;
    }, { operationName: 'textDocument/implementation' });
  }

  async getDocumentSymbols(file: string) {
    return this.run(
      file,
      (client) =>
        client.connection.sendRequest('textDocument/documentSymbol', {
          textDocument: { uri: this.getUri(file) },
        }),
      { operationName: 'textDocument/documentSymbol' },
    );
  }

  async getWorkspaceSymbols(query: string) {
    // Workspace symbols are tricky because we don't have a specific file to determine the client
    // We'll run it on all active clients or pick the first one that supports it

    // ğŸ¯ æ³›åŒ–æ¢æµ‹é€»è¾‘ï¼šæ”¯æŒå¤šç§ä¸»æµè¯­è¨€æœåŠ¡å™¨çš„è‡ªåŠ¨æ¿€æ´»
    if (this.clients.size === 0) {
      console.log('[LSP] No active clients for workspace symbols, probing project...');
      const files = fs.readdirSync(this.projectRoot, { recursive: true }) as string[];

      // æŒ‰ä¼˜å…ˆçº§å’Œå¸¸è§ç¨‹åº¦æ¢æµ‹
      const probeMap = [
        { ext: '.ts', id: 'typescript-language-server' },
        { ext: '.py', id: 'pyright' },
        { ext: '.go', id: 'gopls' },
        { ext: '.rs', id: 'rust-analyzer' },
        { ext: '.js', id: 'typescript-language-server' }
      ];

      for (const probe of probeMap) {
        const foundFile = files.find(f => f.endsWith(probe.ext) && !f.includes('node_modules') && !f.includes('dist'));
        if (foundFile) {
          console.log(`[LSP] Detected ${probe.ext} project, activating ${probe.id}...`);
          const fullPath = path.join(this.projectRoot, foundFile);
          const clients = await this.getClientsForFile(fullPath);
          for (const client of clients) {
            await this.syncDocument(client, fullPath);
          }
          console.log(`[LSP] Waiting 5s for ${probe.id} indexing...`);
          await new Promise(resolve => setTimeout(resolve, 5000));
          break; // æ¿€æ´»ä¸€ä¸ªä¸»è¯­è¨€å³å¯
        }
      }
    }

    const results = [];
    console.log(`[LSP] Searching workspace symbols for "${query}" across ${this.clients.size} clients...`);

    for (const client of this.clients.values()) {
      try {
        // ğŸ¯ æ³›åŒ–é‡è¯•é€»è¾‘ï¼šæ‰€æœ‰å…·å¤‡ç´¢å¼•æ€§è´¨çš„æœåŠ¡å™¨åœ¨å†·å¯åŠ¨æ—¶éƒ½å¯èƒ½è¿”å›ç©º
        let symbols = await client.connection.sendRequest('workspace/symbol', { query });
        if (!symbols || symbols.length === 0) {
          console.log(`[LSP][${client.serverID}] No symbols yet, retrying in 3s...`);
          await new Promise(resolve => setTimeout(resolve, 3000));
          symbols = await client.connection.sendRequest('workspace/symbol', { query });
        }

        console.log(`[LSP][${client.serverID}] Found ${symbols?.length || 0} symbols`);
        if (symbols) results.push(symbols);
      } catch (err) {
        console.error(`[LSP][${client.serverID}] Workspace symbols failed:`, err);
      }
    }
    return results;
  }

  async getDiagnostics(file: string) {
    // è¯Šæ–­é€šå¸¸ç”±æœåŠ¡ç«¯ä¸»åŠ¨æ¨é€ï¼Œè¿™é‡Œæ¼”ç¤ºå¦‚ä½•æ‰‹åŠ¨è§¦å‘ï¼ˆå¦‚æœæ”¯æŒï¼‰æˆ–è·å–ç¼“å­˜
    // å®é™…å®ç°åº”ç›‘å¬ 'textDocument/publishDiagnostics'
    return [];
  }
}
